def weighted_connectivity_matrix(streamlines, folder_name, nii_file, weight_by='pasiS'):
    import matplotlib.pyplot as plt
    import matplotlib.cm as cm
    from dipy.tracking import utils
    from dipy.tracking.streamline import values_from_volume
    import matplotlib.colors as colors

    lab = folder_name+r'\rAAL_highres_atlas.nii'
    lab_file = nib.load(lab)
    lab_labels = lab_file.get_data()
    affine = lab_file.affine
    uni = np.unique(lab_labels)
    lab_labels_index = lab_labels
    for index, i in enumerate(uni):
        lab_labels_index[lab_labels_index == i] = index
    labels_file = open(r'C:\Users\Admin\my_scripts\aal\origin\aal2nii.txt', 'r', errors='ignore')
    labels_name = labels_file.readlines()
    labels_table = []
    labels_headers = []
    for line in labels_name:
        if not line[0] == '#':
            labels_table.append([col for col in line.split(" ") if col])
        elif 'ColHeaders' in line:
            labels_headers = [col for col in line.split(" ") if col]
            labels_headers = labels_headers[2:]
    labels_file.close()
    for i, l in enumerate(labels_table):
        labels_headers.append(l[1])

    # non-weighted:
    m, grouping = utils.connectivity_matrix(streamlines, lab_labels_index, affine=affine,
                                            return_mapping=True,
                                            mapping_as_streamlines=True)
    idxL = np.arange(0,len(m),2)
    idxR = np.arange(1,len(m),2)
    idx = list(idxL)+ list(idxR)
    h = [labels_headers[i] for i in idx]

    mm = m[idx]
    mm = mm[:,idx]
    new_data = 1/mm # values distribute between 0 and 1, 1 represents distant nodes (only 1 tract)
    new_data[new_data>1]=2
    np.save(folder_name+r'non-weighted',new_data)
    plt.figure(1,[24,20])
    cmap = cm.YlOrRd
    cmap.set_over('black')
    plt.imshow(new_data, interpolation='nearest', cmap=cmap, origin='upper',vmax=1.5, norm=colors.LogNorm(vmax=1))
    plt.colorbar()
    plt.xticks(ticks=np.arange(0,len(new_data),1),labels=h)
    plt.yticks(ticks=np.arange(0,len(new_data),1),labels=h)
    plt.title('Non-weighted connectivity matrix', fontsize=16)
    plt.tick_params(axis='x',pad=5.0, labelrotation=90, labelsize=9)
    plt.tick_params(axis='y',pad=5.0, labelsize=9)
    plt.savefig(folder_name+r'\non-weighted(whole brain).png')
    plt.show()

    # weighted:
    weight_by_file = nii_file[:-4:]+'_'+weight_by+'.nii'
    weight_by_img = nib.load(weight_by_file)
    weight_by_data = weight_by_img.get_data()
    affine = weight_by_img.affine
    m_weighted = np.zeros((117, 117), dtype='float64') # !!!!!!!!!!
    for pair,tracts in grouping.items():
        mean_vol_per_tract = []
        vol_per_tract = values_from_volume(weight_by_data, tracts, affine=affine)
        for s in vol_per_tract:
            mean_vol_per_tract.append(np.nanmean(s))
        mean_path_vol = np.nanmean(mean_vol_per_tract)
        m_weighted[pair[0], pair[1]] = mean_path_vol
        m_weighted[pair[1], pair[0]] = mean_path_vol

    mm_weighted = m_weighted[idx]
    mm_weighted = mm_weighted[:,idx]
    mm_weighted[mm_weighted<0.01] = 0
    new_data = 1/(mm_weighted*0.81)
    min_val = new_data[np.isfinite(new_data)].min()
    max_val = new_data[np.isfinite(new_data)].max()
    new_data = (new_data-min_val)/(max_val-min_val)
    new_data[new_data>1] = 2
    np.save(folder_name+r'weighted',new_data)
    plt.figure(1,[24,20])
    cmap = cm.YlOrRd
    cmap.set_over('black')
    plt.imshow(new_data, interpolation='nearest', cmap=cmap, origin='upper', vmax=1.5, norm=colors.LogNorm(vmax=1))
    plt.colorbar()
    plt.xticks(ticks=np.arange(0,len(new_data),1),labels=h)
    plt.yticks(ticks=np.arange(0,len(new_data),1),labels=h)
    plt.title('Weighted connectivity matrix', fontsize=16)
    plt.tick_params(axis='x',pad=5.0, labelrotation=90, labelsize=9)
    plt.tick_params(axis='y',pad=5.0, labelsize=9)
    plt.savefig(folder_name+r'\Weighted(whole brain).png')
    plt.show()


plt.hist(new_data,bins=100)
plt.show()

plt.hist(new_data[new_data<1.5],bins=100)
plt.show()

min_val = new_data[np.isfinite(new_data)].min()
max_val = new_data[np.isfinite(new_data)].max()
new_data = (new_data - min_val) / (max_val - min_val)
new_data[new_data > 1] = 2

plt.hist(new_data[new_data<1.5],bins=100)
plt.show()


import scipy.io as sio
mat=sio.loadmat(r'C:\Users\Admin\my_scripts\aal\megaatlas\rsfmri.mat')
mat = mat['rsfmri']
mat_rev = 1-mat
fig_name = folder_name + r'\rsfmri(whole brain, MegaAtlas).png'
data = mat_rev
data = data[idx]
data = data[:,idx]